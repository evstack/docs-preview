import{_ as l,c as n,j as t,a,b as s,w as o,a4 as c,a3 as d,B as h,o as i,G as p}from"./chunks/framework.BZyQX7AL.js";const x=JSON.parse('{"title":"Rollkit stack","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Rollkit stack | Rollkit"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"learn/stack.md","filePath":"learn/stack.md","lastUpdated":1748003302000}'),u={name:"learn/stack.md"};function m(g,e,k,b,f,y){const r=h("Mermaid");return i(),n("div",null,[e[1]||(e[1]=t("h1",{id:"rollkit-stack",tabindex:"-1"},[a("Rollkit stack "),t("a",{class:"header-anchor",href:"#rollkit-stack","aria-label":'Permalink to "Rollkit stack"'},"​")],-1)),e[2]||(e[2]=t("p",null,"This page will cover the main components of Rollkit.",-1)),e[3]||(e[3]=t("p",null,"Sequencer nodes collect transactions from users, aggregate them into blocks, and post the blocks onto a data availability (DA) layer (such as Celestia) to be ordered and finalized. Full nodes execute and verify blocks, and in the case of an optimistic system, propagate fraud proofs when needed. Light clients will receive headers, verify proofs (fraud, zk, etc), and authenticate trust-minimized queries about the state.",-1)),e[4]||(e[4]=t("h2",{id:"application-structure",tabindex:"-1"},[a("Application structure "),t("a",{class:"header-anchor",href:"#application-structure","aria-label":'Permalink to "Application structure"'},"​")],-1)),(i(),s(c,null,{default:o(()=>[p(r,{id:"mermaid-12",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20A%5BRollkit%5D%0A%20%20%20%20B%5BExecution%20Environment%5D%0A%20%20%20%20C%5BData%20Availability%20Chain%5D%0A%20%20%20%20%0A%20%20%20%20A%20%3C--%3E%7CExecution%20API%7C%20B%0A%20%20%20%20A%20%3C--%3E%7CDA%20API%7C%20C%0A"})]),fallback:o(()=>e[0]||(e[0]=[a(" Loading... ")])),_:1})),e[5]||(e[5]=d(`<h3 id="execution-api" tabindex="-1">Execution API <a class="header-anchor" href="#execution-api" aria-label="Permalink to &quot;Execution API&quot;">​</a></h3><p>Rollkit&#39;s execution API is simple and allows developers to bring their own execution environments instead of using provided ones. The execution API allows the execution environment to do ordering and more intillgently process transcations than what a generalized library could.</p><h4 id="cosmos-sdk" tabindex="-1">Cosmos SDK <a class="header-anchor" href="#cosmos-sdk" aria-label="Permalink to &quot;Cosmos SDK&quot;">​</a></h4><p>Would you like to change your Cosmos SDK application to a Rollkit chain? No problem! All you need to do is use the start function we provide in the ABCI Folder, <a href="./TODO">see here on what changes are needed</a></p><h3 id="data-availability" tabindex="-1">Data availability <a class="header-anchor" href="#data-availability" aria-label="Permalink to &quot;Data availability&quot;">​</a></h3><p><a href="https://github.com/rollkit/rollkit/tree/main/da" target="_blank" rel="noreferrer">Data availability (DA)</a> can be accessed using generic <a href="https://github.com/rollkit/rollkit/blob/main/core/da/da.go" target="_blank" rel="noreferrer">interfaces</a>.</p><p>The <code>BlockRetriever</code> interface serves to enable syncing of full nodes from the data availability layer. It&#39;s important to keep in mind that there is no direct correlation between the DA layer block height and the chain height. Each DA layer block may contain an arbitrary number of blocks.</p><h4 id="celestia" tabindex="-1">Celestia <a class="header-anchor" href="#celestia" aria-label="Permalink to &quot;Celestia&quot;">​</a></h4><p>Celestia is a prominent example of a data availability integration implemented for Rollkit. It&#39;s using the <a href="https://node-rpc-docs.celestia.org" target="_blank" rel="noreferrer">Celestia Node API</a> via the <a href="https://github.com/rollkit/rollkit/tree/main/da" target="_blank" rel="noreferrer"><code>rollkit/da</code></a> package. To deploy a Rollkit chain on Celestia you also have to <a href="https://docs.celestia.org/how-to-guides/celestia-node" target="_blank" rel="noreferrer">run a Celestia light node</a>.</p><h2 id="node-components" tabindex="-1">Node components <a class="header-anchor" href="#node-components" aria-label="Permalink to &quot;Node components&quot;">​</a></h2><h3 id="block-manager" tabindex="-1">Block manager <a class="header-anchor" href="#block-manager" aria-label="Permalink to &quot;Block manager&quot;">​</a></h3><p>The <a href="https://github.com/rollkit/rollkit/tree/main/block" target="_blank" rel="noreferrer">block manager</a> contains routines <code>AggregationLoop</code>, <code>RetrieveLoop</code>, and <code>SyncLoop</code> that communicate through Go channels. These Go routines are run when a Rollkit node starts up (<code>OnStart</code>). Only the sequencer nodes run <code>AggregationLoop</code> which controls the frequency of block production for a chain with a timer as per the <code>BlockTime</code> in <code>BlockManager</code>.</p><p>All nodes run <code>SyncLoop</code> which looks for the following operations:</p><ul><li><strong>Receive block headers</strong>: block headers are received through a channel <code>HeaderInCh</code> and Rollkit nodes attempt to verify the block with the corresponding block data.</li><li><strong>Receive block data</strong>: block bodies are received through a channel <code>blockInCh</code> and Rollkit nodes attempt to verify the block.</li></ul><ul><li>Signal <code>RetrieveLoop</code> with timer as per the <code>DABlockTime</code> in <code>BlockManager</code>.</li></ul><p>All nodes also run <code>RetrieveLoop</code> which is responsible for interacting with the data availability layer. It checks the last updated <code>DAHeight</code> to retrieve a block with timer <code>DABlockTime</code> signaled by <code>SyncLoop</code>. Note that the start height of the DA layer for the chain, <code>DAStartHeight</code>, is configurable in <code>BlockManager</code>.</p><h3 id="comet-rpc" tabindex="-1">Comet RPC <a class="header-anchor" href="#comet-rpc" aria-label="Permalink to &quot;Comet RPC&quot;">​</a></h3><p>Rollkit&#39;s ABCI <a href="https://github.com/rollkit/go-execution-abci/tree/main/pkg/rpc" target="_blank" rel="noreferrer">RPC</a> implements the <a href="https://docs.cometbft.com/v0.37/spec/rpc/" target="_blank" rel="noreferrer">CometBFT RPC</a> interfaces and APIs for querying:</p><ul><li><strong>Information about the node</strong>: information such as node&#39;s health, status, and network info.</li><li><strong>The blockchain</strong>: getting information about the blockchain such as blocks and block headers.</li><li><strong>The transactions</strong>: getting transaction information and broadcasting raw transactions, with search capabilities.</li><li><strong>ABCI</strong>: application information.</li></ul><p>The following RPC protocols are currently supported:</p><ul><li>URI over HTTP</li><li>JSON-RPC over HTTP</li><li>JSON-RPC over WebSockets</li></ul><p>The RPC provides an additional query for DA included blocks using the <code>height</code> parameter:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://127.0.0.1:26657/block?height=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> http://127.0.0.1:26657/block?height=included</span></span></code></pre></div><h4 id="parameters" tabindex="-1">Parameters <a class="header-anchor" href="#parameters" aria-label="Permalink to &quot;Parameters&quot;">​</a></h4><ul><li>height (integer or string): height of the requested block. If no height is specified the latest block will be used. If height is set to the string &quot;included&quot;, the latest DA included block will be returned.</li></ul><h3 id="p2p-layer" tabindex="-1">P2P layer <a class="header-anchor" href="#p2p-layer" aria-label="Permalink to &quot;P2P layer&quot;">​</a></h3><p>Rollkit&#39;s <a href="https://github.com/rollkit/rollkit/tree/main/p2p" target="_blank" rel="noreferrer">P2P layer</a> enables direct communication between nodes. It&#39;s used to gossip transactions, headers of newly created blocks, and state fraud proofs. The P2P layer is implemented using <a href="https://github.com/libp2p" target="_blank" rel="noreferrer">libp2p</a>.</p><p>Rollkit uses <a href="https://curriculum.pl-launchpad.io/curriculum/libp2p/dht/" target="_blank" rel="noreferrer">DHT-based active peer discovery</a>. Starting a node connects to pre-configured bootstrap peers, and advertises its namespace ID in the DHT. This solution is flexible, because multiple networks may reuse the same DHT/bootstrap nodes, but specific network might decide to use dedicated nodes as well.</p><h2 id="rollkit-node-types" tabindex="-1">Rollkit node types <a class="header-anchor" href="#rollkit-node-types" aria-label="Permalink to &quot;Rollkit node types&quot;">​</a></h2><p>Rollkit nodes are implemented in the <a href="https://github.com/rollkit/rollkit/tree/main/node" target="_blank" rel="noreferrer"><code>node</code></a> package.</p><h3 id="full-node" tabindex="-1">Full node <a class="header-anchor" href="#full-node" aria-label="Permalink to &quot;Full node&quot;">​</a></h3><p>Full nodes verify all blocks, and produce fraud proofs for optimistic systems. Since they fully verify all blocks, they don&#39;t rely on fraud or validity proofs for security.</p><h3 id="sequencer-node" tabindex="-1">Sequencer node <a class="header-anchor" href="#sequencer-node" aria-label="Permalink to &quot;Sequencer node&quot;">​</a></h3><p>Sequencer nodes can be utilized. Sequencers are block producers, responsible for aggregating transactions into blocks, and typically executing transactions to produce a state root, used by the light clients.</p><p>Rollkit plans to support multiple different pluggable sequencer schemes:</p><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">Deploy in one-click</th><th style="text-align:center;">Faster soft-confirmations than L1</th><th style="text-align:center;">Control over transaction ordering</th><th style="text-align:center;">Atomic composability with other chains</th><th style="text-align:center;">Censorship resistance</th><th style="text-align:center;">Implementation Status</th></tr></thead><tbody><tr><td style="text-align:center;">Single sequencer</td><td style="text-align:center;">Requires spinning up a sequencer</td><td style="text-align:center;">Yes ✅</td><td style="text-align:center;">Yes ✅</td><td style="text-align:center;">No ❌</td><td style="text-align:center;">Eventual ⏳*</td><td style="text-align:center;">✅ Implemented!</td></tr><tr><td style="text-align:center;">Based sequencer</td><td style="text-align:center;">Requires spinning up a gateway</td><td style="text-align:center;">No ❌</td><td style="text-align:center;">Yes ✅</td><td style="text-align:center;">No ❌</td><td style="text-align:center;">Yes ✅</td><td style="text-align:center;">Planned</td></tr></tbody></table><h2 id="state-validity-modes" tabindex="-1">State validity modes <a class="header-anchor" href="#state-validity-modes" aria-label="Permalink to &quot;State validity modes&quot;">​</a></h2><h3 id="pessimistic-full-nodes-only" tabindex="-1">Pessimistic (full nodes only) <a class="header-anchor" href="#pessimistic-full-nodes-only" aria-label="Permalink to &quot;Pessimistic (full nodes only)&quot;">​</a></h3><p>A pessimistic system is one that only supports full nodes that replay all the transactions in the system in order to check its validity. Rollkit supports pessimistic operation by default.</p><p>This pessimistic mode of operation is similar to how Tether uses Bitcoin as a data availability layer via <a href="https://github.com/OmniLayer/spec/blob/master/OmniSpecification-v0.6.adoc#summary" target="_blank" rel="noreferrer">OmniLayer</a>.</p>`,40))])}const q=l(u,[["render",m]]);export{x as __pageData,q as default};
