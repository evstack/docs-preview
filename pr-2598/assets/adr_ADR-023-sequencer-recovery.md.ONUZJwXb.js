import{_ as a,c as t,ag as o,o as r}from"./chunks/framework.LfVnamrF.js";const g=JSON.parse('{"title":"ADR 023: Sequencer Recovery & Liveness — Rafted Conductor vs 1‑Active/1‑Failover","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"ADR 023: Sequencer Recovery & Liveness — Rafted Conductor vs 1‑Active/1‑Failover | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"adr/ADR-023-sequencer-recovery.md","filePath":"adr/ADR-023-sequencer-recovery.md","lastUpdated":1756112516000}'),n={name:"adr/ADR-023-sequencer-recovery.md"};function i(s,e,l,c,d,u){return r(),t("div",null,e[0]||(e[0]=[o('<h1 id="adr-023-sequencer-recovery-liveness-—-rafted-conductor-vs-1‐active-1‐failover" tabindex="-1">ADR 023: Sequencer Recovery &amp; Liveness — Rafted Conductor vs 1‑Active/1‑Failover <a class="header-anchor" href="#adr-023-sequencer-recovery-liveness-—-rafted-conductor-vs-1‐active-1‐failover" aria-label="Permalink to &quot;ADR 023: Sequencer Recovery &amp; Liveness — Rafted Conductor vs 1‑Active/1‑Failover&quot;">​</a></h1><h2 id="changelog" tabindex="-1">Changelog <a class="header-anchor" href="#changelog" aria-label="Permalink to &quot;Changelog&quot;">​</a></h2><ul><li>2025-08-21: Initial ADR authored; compared approaches and captured failover and escape‑hatch semantics.</li></ul><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>We need a robust, deterministic way to keep L2 block production live when the primary sequencer becomes unhealthy or unreachable, and to <strong>recover leadership</strong> without split‑brain or unsafe reorgs. The solution must integrate cleanly with <code>ev-node</code>, be observable, and support zero‑downtime upgrades. This ADR evaluates two designs for the <strong>control plane</strong> that governs which node is allowed to run the sequencer process.</p><h2 id="alternative-approaches" tabindex="-1">Alternative Approaches <a class="header-anchor" href="#alternative-approaches" aria-label="Permalink to &quot;Alternative Approaches&quot;">​</a></h2><p>Considered but not chosen for this iteration:</p><ul><li><strong>Many replicas, no coordination</strong>: high risk of <strong>simultaneous leaders</strong> (split‑brain) and soft‑confirmation reversals.</li><li><strong>Full BFT consensus among sequencers</strong>: heavier operational/engineering cost than needed; our fault model is crash‑fault tolerance with honest operators.</li><li><strong>Outsource ordering to a shared sequencer network</strong>: viable but introduces an external dependency and different SLOs; out of scope for the immediate milestone.</li><li><strong>Manual failover only</strong>: too slow and error‑prone for production SLOs.</li></ul><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><blockquote><p>We will operate <strong>1 active + 1 failover</strong> sequencer at all times, regardless of control plane. Two implementation options are approved:</p></blockquote><ul><li><p><strong>Design A — Rafted Conductor (CFT)</strong>: A sidecar <em>conductor</em> runs next to each <code>ev-node</code>. Conductors form a <strong>Raft</strong> cluster to elect a single leader and <strong>gate</strong> sequencing so only the leader may produce blocks. For quorum while running 1‑active/2‑failover semantics, we will run <strong>1 sequencer nodes + 2 failover</strong> (no sequencer) as the third Raft voter. <em>Note:</em> OP Stack uses a very similar pattern for its sequencer; see <code>op-conductor</code> in References.</p></li><li><p><strong>Design B — 1‑Active / 1‑Failover (Lease/Lock)</strong>: One hot standby promotes itself when the active fails by acquiring a <strong>lease/lock</strong> (e.g., Kubernetes Lease or external KV). Strong <strong>fencing</strong> ensures the old leader cannot keep producing after lease loss.</p></li></ul><p><strong>Why both assume 1A/1F:</strong> Even with Raft, we intentionally keep <strong>n</strong> nodes on hot standby capable of immediate promotion; additional nodes may exist as <strong>read‑only</strong> or <strong>witness</strong> roles to strengthen quorum without enabling extra leaders.</p><p>Status of this decision: <strong>Proposed</strong> for implementation and test hardening.</p><h2 id="detailed-design" tabindex="-1">Detailed Design <a class="header-anchor" href="#detailed-design" aria-label="Permalink to &quot;Detailed Design&quot;">​</a></h2><h3 id="user-requirements" tabindex="-1">User requirements <a class="header-anchor" href="#user-requirements" aria-label="Permalink to &quot;User requirements&quot;">​</a></h3><ul><li><strong>No split‑brain</strong>: at most one sequencer is active.</li><li><strong>Deterministic recovery</strong>: new leader starts from a known <strong>unsafe head</strong>.</li><li><strong>Fast failover</strong>: p50 ≤ 15s, p95 ≤ 45s.</li><li><strong>Operational clarity</strong>: health metrics, leader identity, and explicit admin controls.</li><li><strong>Zero‑downtime upgrades</strong>: blue/green leadership transfer.</li></ul><h3 id="systems-affected" tabindex="-1">Systems affected <a class="header-anchor" href="#systems-affected" aria-label="Permalink to &quot;Systems affected&quot;">​</a></h3><ul><li><code>ev-node</code> (sequencer control hooks, health surface).</li><li>New sidecar(s): <strong>conductor</strong> (Design A) or <strong>lease‑manager</strong> (Design B).</li><li>RPC ingress (optional <strong>leader‑aware proxy</strong> to route sequencing endpoints only to the leader).</li><li>CI/CD &amp; SRE runbooks, dashboards, alerts.</li></ul><h3 id="new-changed-data-structures" tabindex="-1">New/changed data structures <a class="header-anchor" href="#new-changed-data-structures" aria-label="Permalink to &quot;New/changed data structures&quot;">​</a></h3><ul><li><strong>UnsafeHead</strong> record persisted by control plane: <code>(l2_number, l2_hash, l1_origin, timestamp)</code>.</li><li><strong>Design A (Raft)</strong>: replicated <strong>Raft log</strong> entries for <code>UnsafeHead</code>, <code>LeadershipTerm</code>, and optional <code>CommitMeta</code> (batch/DA pointers); periodic snapshots.</li><li><strong>Design B (Lease)</strong>: a single <strong>Lease</strong> record (Kubernetes Lease or external KV entry) plus a monotonic <strong>lease token</strong> for fencing.</li></ul><h3 id="new-changed-apis" tabindex="-1">New/changed APIs <a class="header-anchor" href="#new-changed-apis" aria-label="Permalink to &quot;New/changed APIs&quot;">​</a></h3><p>Introduce an <strong>Admin RPC</strong> (gRPC/HTTP) on <code>ev-node</code> (or a thin shim) used by either control plane:</p><ul><li><code>StartSequencer(from_unsafe_head: bool)</code> — start sequencing, optionally pinning to the last persisted UnsafeHead.</li><li><code>StopSequencer()</code> — hard stop; no more block production.</li><li><code>SequencerHealthy()</code> → <code>{ healthy, l2_number, l2_hash, l1_origin, peer_count, da_height, last_err }</code></li><li><code>Status()</code> → <code>{ sequencer_active, build_height, leader_hint?, last_err }</code></li></ul><p>These are additive and should not break existing RPCs.</p><h3 id="efficiency-considerations" tabindex="-1">Efficiency considerations <a class="header-anchor" href="#efficiency-considerations" aria-label="Permalink to &quot;Efficiency considerations&quot;">​</a></h3><ul><li><strong>Design A:</strong> Raft heartbeats and snapshotting add small steady‑state overhead; no impact on throughput when healthy.</li><li><strong>Design B:</strong> Lease renewals are lightweight; performance dominated by <code>ev-node</code> itself.</li></ul><h3 id="expected-access-patterns" tabindex="-1">Expected access patterns <a class="header-anchor" href="#expected-access-patterns" aria-label="Permalink to &quot;Expected access patterns&quot;">​</a></h3><ul><li>Reads (RPC, state) should work on all nodes; <strong>writes/sequence endpoints</strong> only on the active leader. If a leader‑aware proxy is deployed, it enforces this automatically.</li></ul><h3 id="logging-monitoring-observability" tabindex="-1">Logging/Monitoring/Observability <a class="header-anchor" href="#logging-monitoring-observability" aria-label="Permalink to &quot;Logging/Monitoring/Observability&quot;">​</a></h3><ul><li>Metrics: <code>leader_id</code>, <code>raft_term</code> (A), <code>lease_owner</code> (B), <code>unsafe_head_advance</code>, <code>peer_count</code>, <code>rpc_error_rate</code>, <code>da_publish_latency</code>, <code>backlog</code>.</li><li>Alerts: no unsafe advance &gt; 3× block time; unexpected leader churn; lease lost but sequencer still active (fencing breach).</li><li>Logs: audit all <strong>Start/Stop</strong> decisions and override operations.</li></ul><h3 id="security-considerations" tabindex="-1">Security considerations <a class="header-anchor" href="#security-considerations" aria-label="Permalink to &quot;Security considerations&quot;">​</a></h3><ul><li>Lock down <strong>Admin RPC</strong> with mTLS + RBAC; only the sidecar/process account may call Start/Stop.</li><li>Implement <strong>fencing</strong>: leader periodically validates it still holds leadership/lease; otherwise self‑stops.</li><li>Break‑glass overrides must be gated behind separate credentials and produce auditable events.</li></ul><h3 id="privacy-considerations" tabindex="-1">Privacy considerations <a class="header-anchor" href="#privacy-considerations" aria-label="Permalink to &quot;Privacy considerations&quot;">​</a></h3><ul><li>None beyond existing node telemetry; no user data added.</li></ul><h3 id="testing-plan" tabindex="-1">Testing plan <a class="header-anchor" href="#testing-plan" aria-label="Permalink to &quot;Testing plan&quot;">​</a></h3><ul><li>Kill active sequencer → verify failover within SLO; assert <strong>no double leadership</strong>.</li><li>Partition tests: only Raft majority (A) or lease holder (B) may produce.</li><li>Blue/green: explicit leadership handoff; confirm unsafe head continuity.</li><li>Misconfigured standby → failover should <strong>refuse</strong>; alarms fire.</li><li>Long‑duration outage drills; confirm user‑facing status and catch‑up behavior.</li></ul><h3 id="change-breakdown" tabindex="-1">Change breakdown <a class="header-anchor" href="#change-breakdown" aria-label="Permalink to &quot;Change breakdown&quot;">​</a></h3><ul><li>Phase 1: Implement Admin RPC + health surface in <code>ev-node</code>; add sidecar skeletons.</li><li>Phase 2: Integrate Design A (Raft) in a 1 sequencer + 2 failover; build dashboards/runbooks.</li><li>Phase 3: Add Design B (Lease) profile for small/test clusters; share common health logic.</li><li>Phase 4: Game days and SLO validation; finalize SRE playbooks.</li></ul><h3 id="release-compatibility" tabindex="-1">Release/compatibility <a class="header-anchor" href="#release-compatibility" aria-label="Permalink to &quot;Release/compatibility&quot;">​</a></h3><ul><li><strong>Breaking release?</strong> No — Admin RPCs are additive.</li></ul><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><p>Proposed</p><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><h3 id="positive" tabindex="-1">Positive <a class="header-anchor" href="#positive" aria-label="Permalink to &quot;Positive&quot;">​</a></h3><ul><li>Clear, deterministic leadership with fencing; supports zero‑downtime upgrades.</li><li>Works with <code>ev-node</code> via a small, well‑defined Admin RPC.</li><li>Choice of control plane allows right‑sizing ops: Raft for prod; Lease for small/test.</li></ul><h3 id="negative" tabindex="-1">Negative <a class="header-anchor" href="#negative" aria-label="Permalink to &quot;Negative&quot;">​</a></h3><ul><li>Design A adds Raft operational overhead (quorum management, snapshots).</li><li>Design B has a smaller blast radius but does not generalize to N replicas; stricter reliance on correct fencing.</li><li>Additional components (sidecars, proxies) increase deployment surface.</li></ul><h3 id="neutral" tabindex="-1">Neutral <a class="header-anchor" href="#neutral" aria-label="Permalink to &quot;Neutral&quot;">​</a></h3><ul><li>Small steady‑state CPU/network overhead for heartbeats/leases; negligible compared to sequencing and DA posting.</li></ul><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><p><strong>OP conductor</strong> (industry prior art; similar to Design A):</p><ul><li>Docs: <a href="https://docs.optimism.io/operators/chain-operators/tools/op-conductor" target="_blank" rel="noreferrer">https://docs.optimism.io/operators/chain-operators/tools/op-conductor</a></li><li>README: <a href="https://github.com/ethereum-optimism/optimism/blob/develop/op-conductor/README.md" target="_blank" rel="noreferrer">https://github.com/ethereum-optimism/optimism/blob/develop/op-conductor/README.md</a></li></ul></li><li><p><strong><code>ev-node</code></strong> (architecture, sequencing):</p><ul><li>Repo: <a href="https://github.com/evstack/ev-node" target="_blank" rel="noreferrer">https://github.com/evstack/ev-node</a></li><li>Quick start: <a href="https://ev.xyz/guides/quick-start" target="_blank" rel="noreferrer">https://ev.xyz/guides/quick-start</a></li><li>Discussions/issues on sequencing API &amp; multi-sequencer behavior.</li></ul></li><li><p><strong>Lease-based leader election</strong>:</p><ul><li>Kubernetes Lease API: <a href="https://kubernetes.io/docs/concepts/architecture/leases/" target="_blank" rel="noreferrer">https://kubernetes.io/docs/concepts/architecture/leases/</a></li><li>client-go leader election helpers: <a href="https://pkg.go.dev/k8s.io/client-go/tools/leaderelection" target="_blank" rel="noreferrer">https://pkg.go.dev/k8s.io/client-go/tools/leaderelection</a></li></ul></li></ul>',51)]))}const p=a(n,[["render",i]]);export{g as __pageData,p as default};
