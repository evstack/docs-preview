import{_ as a,c as n,ag as s,o as t}from"./chunks/framework.LfVnamrF.js";const h=JSON.parse('{"title":"ADR 023: Sequencer Recovery & Liveness — Rafted Conductor vs 1‑Active/1‑Failover","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"ADR 023: Sequencer Recovery & Liveness — Rafted Conductor vs 1‑Active/1‑Failover | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"adr/ADR-023-sequencer-recovery.md","filePath":"adr/ADR-023-sequencer-recovery.md","lastUpdated":1756138515000}'),i={name:"adr/ADR-023-sequencer-recovery.md"};function o(r,e,l,p,c,d){return t(),n("div",null,e[0]||(e[0]=[s(`<h1 id="adr-023-sequencer-recovery-liveness-—-rafted-conductor-vs-1‐active-1‐failover" tabindex="-1">ADR 023: Sequencer Recovery &amp; Liveness — Rafted Conductor vs 1‑Active/1‑Failover <a class="header-anchor" href="#adr-023-sequencer-recovery-liveness-—-rafted-conductor-vs-1‐active-1‐failover" aria-label="Permalink to &quot;ADR 023: Sequencer Recovery &amp; Liveness — Rafted Conductor vs 1‑Active/1‑Failover&quot;">​</a></h1><h2 id="changelog" tabindex="-1">Changelog <a class="header-anchor" href="#changelog" aria-label="Permalink to &quot;Changelog&quot;">​</a></h2><ul><li>2025-08-21: Initial ADR authored; compared approaches and captured failover and escape‑hatch semantics.</li></ul><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>We need a robust, deterministic way to keep L2 block production live when the primary sequencer becomes unhealthy or unreachable, and to <strong>recover leadership</strong> without split‑brain or unsafe reorgs. The solution must integrate cleanly with <code>ev-node</code>, be observable, and support zero‑downtime upgrades. This ADR evaluates two designs for the <strong>control plane</strong> that governs which node is allowed to run the sequencer process.</p><h2 id="alternative-approaches" tabindex="-1">Alternative Approaches <a class="header-anchor" href="#alternative-approaches" aria-label="Permalink to &quot;Alternative Approaches&quot;">​</a></h2><p>Considered but not chosen for this iteration:</p><ul><li><strong>Many replicas, no coordination</strong>: high risk of <strong>simultaneous leaders</strong> (split‑brain) and soft‑confirmation reversals.</li><li><strong>Full BFT consensus among sequencers</strong>: heavier operational/engineering cost than needed; our fault model is crash‑fault tolerance with honest operators.</li><li><strong>Outsource ordering to a shared sequencer network</strong>: viable but introduces an external dependency and different SLOs; out of scope for the immediate milestone.</li><li><strong>Manual failover only</strong>: too slow and error‑prone for production SLOs.</li></ul><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><blockquote><p>We will operate <strong>1 active + 1 failover</strong> sequencer at all times, regardless of control plane. Two implementation options are approved:</p></blockquote><ul><li><p><strong>Design A — Rafted Conductor (CFT)</strong>: A sidecar <em>conductor</em> runs next to each <code>ev-node</code>. Conductors form a <strong>Raft</strong> cluster to elect a single leader and <strong>gate</strong> sequencing so only the Raft leader may produce blocks via the Admin Control API. Applicability: use Raft only when there are <strong>≥ 3 sequencers</strong> (prefer odd N: 3, 5, …). Do not use Raft for two-node 1‑active/1‑failover clusters; use Design B in that case. <em>Note:</em> OP Stack uses a very similar pattern for its sequencer; see <code>op-conductor</code> in References.</p></li><li><p><strong>Design B — 1‑Active / 1‑Failover (Lease/Lock)</strong>: One hot standby promotes itself when the active fails by acquiring a <strong>lease/lock</strong> (e.g., Kubernetes Lease or external KV). Strong <strong>fencing</strong> ensures the old leader cannot keep producing after lease loss.</p></li></ul><p><strong>Why both assume 1A/1F:</strong> Even with Raft, we intentionally keep <strong>n</strong> nodes on hot standby capable of immediate promotion; additional nodes may exist as <strong>read‑only</strong> or <strong>witness</strong> roles to strengthen quorum without enabling extra leaders.</p><p>Status of this decision: <strong>Proposed</strong> for implementation and test hardening.</p><h2 id="detailed-design" tabindex="-1">Detailed Design <a class="header-anchor" href="#detailed-design" aria-label="Permalink to &quot;Detailed Design&quot;">​</a></h2><h3 id="user-requirements" tabindex="-1">User requirements <a class="header-anchor" href="#user-requirements" aria-label="Permalink to &quot;User requirements&quot;">​</a></h3><ul><li><strong>No split‑brain</strong>: at most one sequencer is active.</li><li><strong>Deterministic recovery</strong>: new leader starts from a known <strong>unsafe head</strong>.</li><li><strong>Fast failover</strong>: p50 ≤ 15s, p95 ≤ 45s.</li><li><strong>Operational clarity</strong>: health metrics, leader identity, and explicit admin controls.</li><li><strong>Zero‑downtime upgrades</strong>: blue/green leadership transfer.</li></ul><h3 id="systems-affected" tabindex="-1">Systems affected <a class="header-anchor" href="#systems-affected" aria-label="Permalink to &quot;Systems affected&quot;">​</a></h3><ul><li><code>ev-node</code> (sequencer control hooks, health surface).</li><li>New sidecar(s): <strong>conductor</strong> (Design A) or <strong>lease‑manager</strong> (Design B).</li><li>RPC ingress (optional <strong>leader‑aware proxy</strong> to route sequencing endpoints only to the leader).</li><li>CI/CD &amp; SRE runbooks, dashboards, alerts.</li></ul><h3 id="new-changed-data-structures" tabindex="-1">New/changed data structures <a class="header-anchor" href="#new-changed-data-structures" aria-label="Permalink to &quot;New/changed data structures&quot;">​</a></h3><ul><li><strong>UnsafeHead</strong> record persisted by control plane: <code>(l2_number, l2_hash, l1_origin, timestamp)</code>.</li><li><strong>Design A (Raft)</strong>: replicated <strong>Raft log</strong> entries for <code>UnsafeHead</code>, <code>LeadershipTerm</code>, and optional <code>CommitMeta</code> (batch/DA pointers); periodic snapshots.</li><li><strong>Design B (Lease)</strong>: a single <strong>Lease</strong> record (Kubernetes Lease or external KV entry) plus a monotonic <strong>lease token</strong> for fencing.</li></ul><h3 id="admin-control-api-protobuf" tabindex="-1">Admin Control API (Protobuf) <a class="header-anchor" href="#admin-control-api-protobuf" aria-label="Permalink to &quot;Admin Control API (Protobuf)&quot;">​</a></h3><p>We introduce a separate, authenticated Admin Control API dedicated to sequencing control. This API is not exposed on the public RPC endpoint and binds to a distinct listener (port/interface, e.g., <code>:8443</code> on an internal network or loopback-only in single-host deployments). It is used exclusively by the conductor/lease-manager and by privileged operator automation for break-glass procedures.</p><p>Service overview:</p><ul><li>StartSequencer: Arms/starts sequencing subject to fencing (valid lease/term) and optionally pins to last persisted UnsafeHead.</li><li>StopSequencer: Hard stop with optional “force” semantics.</li><li>PrepareHandoff / CompleteHandoff: Explicit, auditable, two-phase, blue/green leadership transfer.</li><li>Health / Status: Health probes and machine-readable node + leader state.</li></ul><p>Endpoint separation:</p><ul><li>Public JSON-RPC and P2P endpoints remain unchanged.</li><li>Admin Control API is out-of-band and must not be routed through public ingress. It sits behind mTLS and strict network policy.</li></ul><p>Protobuf schema (proposed file: <code>proto/evnode/admin/v1/control.proto</code>):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>syntax = &quot;proto3&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>package evnode.admin.v1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>option go_package = &quot;github.com/evstack/ev-node/types/pb/evnode/admin/v1;adminv1&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ControlService governs sequencer lifecycle and health surfaces.</span></span>
<span class="line"><span>// All operations must be authenticated via mTLS and authorized via RBAC.</span></span>
<span class="line"><span>service ControlService {</span></span>
<span class="line"><span>  // StartSequencer starts sequencing if and only if the caller holds leadership/fencing.</span></span>
<span class="line"><span>  rpc StartSequencer(StartSequencerRequest) returns (StartSequencerResponse);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // StopSequencer stops sequencing. If force=true, cancels in-flight loops ASAP.</span></span>
<span class="line"><span>  rpc StopSequencer(StopSequencerRequest) returns (StopSequencerResponse);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // PrepareHandoff transitions current leader to a safe ready-to-yield state</span></span>
<span class="line"><span>  // and issues a handoff ticket bound to the current term/unsafe head.</span></span>
<span class="line"><span>  rpc PrepareHandoff(PrepareHandoffRequest) returns (PrepareHandoffResponse);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // CompleteHandoff is called by the target node to atomically assume leadership</span></span>
<span class="line"><span>  // using the handoff ticket. Enforces fencing and continuity from UnsafeHead.</span></span>
<span class="line"><span>  rpc CompleteHandoff(CompleteHandoffRequest) returns (CompleteHandoffResponse);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Health returns node-local liveness and recent errors.</span></span>
<span class="line"><span>  rpc Health(HealthRequest) returns (HealthResponse);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Status returns leader/term, active/standby, and build info.</span></span>
<span class="line"><span>  rpc Status(StatusRequest) returns (StatusResponse);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message UnsafeHead {</span></span>
<span class="line"><span>  uint64 l2_number = 1;</span></span>
<span class="line"><span>  bytes  l2_hash   = 2; // 32 bytes</span></span>
<span class="line"><span>  string l1_origin = 3; // opaque or hash/height string</span></span>
<span class="line"><span>  int64  timestamp = 4; // unix seconds</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message LeadershipTerm {</span></span>
<span class="line"><span>  uint64 term      = 1; // monotonic term/epoch for fencing</span></span>
<span class="line"><span>  string leader_id = 2; // conductor/node ID</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message StartSequencerRequest {</span></span>
<span class="line"><span>  bool   from_unsafe_head = 1;  // if false, uses safe head per policy</span></span>
<span class="line"><span>  bytes  lease_token      = 2;  // opaque, issued by control plane (Raft/Lease)</span></span>
<span class="line"><span>  string reason           = 3;  // audit string</span></span>
<span class="line"><span>  string idempotency_key  = 4;  // optional, de-duplicate retries</span></span>
<span class="line"><span>  string requester        = 5;  // principal for audit</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>message StartSequencerResponse {</span></span>
<span class="line"><span>  bool            activated = 1;</span></span>
<span class="line"><span>  LeadershipTerm  term      = 2;</span></span>
<span class="line"><span>  UnsafeHead      unsafe    = 3;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message StopSequencerRequest {</span></span>
<span class="line"><span>  bytes  lease_token     = 1;</span></span>
<span class="line"><span>  bool   force           = 2;</span></span>
<span class="line"><span>  string reason          = 3;</span></span>
<span class="line"><span>  string idempotency_key = 4;</span></span>
<span class="line"><span>  string requester       = 5;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>message StopSequencerResponse {</span></span>
<span class="line"><span>  bool stopped = 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message PrepareHandoffRequest {</span></span>
<span class="line"><span>  bytes  lease_token     = 1;</span></span>
<span class="line"><span>  string target_id       = 2; // logical target node ID</span></span>
<span class="line"><span>  string reason          = 3;</span></span>
<span class="line"><span>  string idempotency_key = 4;</span></span>
<span class="line"><span>  string requester       = 5;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>message PrepareHandoffResponse {</span></span>
<span class="line"><span>  bytes           handoff_ticket = 1; // opaque, bound to term+unsafe head</span></span>
<span class="line"><span>  LeadershipTerm  term           = 2;</span></span>
<span class="line"><span>  UnsafeHead      unsafe         = 3;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message CompleteHandoffRequest {</span></span>
<span class="line"><span>  bytes  handoff_ticket  = 1;</span></span>
<span class="line"><span>  string requester       = 2;</span></span>
<span class="line"><span>  string idempotency_key = 3;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>message CompleteHandoffResponse {</span></span>
<span class="line"><span>  bool           activated = 1;</span></span>
<span class="line"><span>  LeadershipTerm term      = 2;</span></span>
<span class="line"><span>  UnsafeHead     unsafe    = 3;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message HealthRequest {}</span></span>
<span class="line"><span>message HealthResponse {</span></span>
<span class="line"><span>  bool   healthy     = 1;</span></span>
<span class="line"><span>  uint64 l2_number   = 2;</span></span>
<span class="line"><span>  bytes  l2_hash     = 3;</span></span>
<span class="line"><span>  string l1_origin   = 4;</span></span>
<span class="line"><span>  uint64 peer_count  = 5;</span></span>
<span class="line"><span>  uint64 da_height   = 6;</span></span>
<span class="line"><span>  string last_err    = 7;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message StatusRequest {}</span></span>
<span class="line"><span>message StatusResponse {</span></span>
<span class="line"><span>  bool   sequencer_active = 1;</span></span>
<span class="line"><span>  string build_version    = 2;</span></span>
<span class="line"><span>  string leader_hint      = 3; // optional, human-readable</span></span>
<span class="line"><span>  string last_err         = 4;</span></span>
<span class="line"><span>  LeadershipTerm term     = 5;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Error semantics:</p><ul><li>PERMISSION_DENIED: AuthN/AuthZ failure, missing or invalid mTLS identity.</li><li>FAILED_PRECONDITION: Missing/expired lease or fencing violation; handoff ticket invalid.</li><li>ABORTED: Lost leadership mid-flight; TOCTOU fencing triggered self-stop.</li><li>ALREADY_EXISTS: Start requested but sequencer already active with same term.</li><li>UNAVAILABLE: Local dependencies not ready (DA client, exec engine).</li></ul><h3 id="efficiency-considerations" tabindex="-1">Efficiency considerations <a class="header-anchor" href="#efficiency-considerations" aria-label="Permalink to &quot;Efficiency considerations&quot;">​</a></h3><ul><li><strong>Design A:</strong> Raft heartbeats and snapshotting add small steady‑state overhead; no impact on throughput when healthy.</li><li><strong>Design B:</strong> Lease renewals are lightweight; performance dominated by <code>ev-node</code> itself.</li></ul><h3 id="expected-access-patterns" tabindex="-1">Expected access patterns <a class="header-anchor" href="#expected-access-patterns" aria-label="Permalink to &quot;Expected access patterns&quot;">​</a></h3><ul><li>Reads (RPC, state) should work on all nodes; <strong>writes/sequence endpoints</strong> only on the active leader. If a leader‑aware proxy is deployed, it enforces this automatically.</li></ul><h3 id="logging-monitoring-observability" tabindex="-1">Logging/Monitoring/Observability <a class="header-anchor" href="#logging-monitoring-observability" aria-label="Permalink to &quot;Logging/Monitoring/Observability&quot;">​</a></h3><ul><li>Metrics: <code>leader_id</code>, <code>raft_term</code> (A), <code>lease_owner</code> (B), <code>unsafe_head_advance</code>, <code>peer_count</code>, <code>rpc_error_rate</code>, <code>da_publish_latency</code>, <code>backlog</code>.</li><li>Alerts: no unsafe advance &gt; 3× block time; unexpected leader churn; lease lost but sequencer still active (fencing breach).</li><li>Logs: audit all <strong>Start/Stop</strong> decisions and override operations.</li></ul><h3 id="security-considerations" tabindex="-1">Security considerations <a class="header-anchor" href="#security-considerations" aria-label="Permalink to &quot;Security considerations&quot;">​</a></h3><ul><li>Lock down <strong>Admin RPC</strong> with mTLS + RBAC; only the sidecar/process account may call Start/Stop.</li><li>Implement <strong>fencing</strong>: leader periodically validates it still holds leadership/lease; otherwise self‑stops.</li><li>Break‑glass overrides must be gated behind separate credentials and produce auditable events.</li></ul><h3 id="privacy-considerations" tabindex="-1">Privacy considerations <a class="header-anchor" href="#privacy-considerations" aria-label="Permalink to &quot;Privacy considerations&quot;">​</a></h3><ul><li>None beyond existing node telemetry; no user data added.</li></ul><h3 id="testing-plan" tabindex="-1">Testing plan <a class="header-anchor" href="#testing-plan" aria-label="Permalink to &quot;Testing plan&quot;">​</a></h3><ul><li>Kill active sequencer → verify failover within SLO; assert <strong>no double leadership</strong>.</li><li>Partition tests: only Raft majority (A) or lease holder (B) may produce.</li><li>Blue/green: explicit leadership handoff; confirm unsafe head continuity.</li><li>Misconfigured standby → failover should <strong>refuse</strong>; alarms fire.</li><li>Long‑duration outage drills; confirm user‑facing status and catch‑up behavior.</li></ul><h3 id="change-breakdown" tabindex="-1">Change breakdown <a class="header-anchor" href="#change-breakdown" aria-label="Permalink to &quot;Change breakdown&quot;">​</a></h3><ul><li>Phase 1: Implement Admin RPC + health surface in <code>ev-node</code>; add sidecar skeletons.</li><li>Phase 2: Integrate Design A (Raft) in a 1 sequencer + 2 failover; build dashboards/runbooks.</li><li>Phase 3: Add Design B (Lease) profile for small/test clusters; share common health logic.</li><li>Phase 4: Game days and SLO validation; finalize SRE playbooks.</li></ul><h3 id="release-compatibility" tabindex="-1">Release/compatibility <a class="header-anchor" href="#release-compatibility" aria-label="Permalink to &quot;Release/compatibility&quot;">​</a></h3><ul><li><strong>Breaking release?</strong> No — Admin RPCs are additive.</li></ul><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><p>Proposed</p><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><h3 id="positive" tabindex="-1">Positive <a class="header-anchor" href="#positive" aria-label="Permalink to &quot;Positive&quot;">​</a></h3><ul><li>Clear, deterministic leadership with fencing; supports zero‑downtime upgrades.</li><li>Works with <code>ev-node</code> via a small, well‑defined Admin RPC.</li><li>Choice of control plane allows right‑sizing ops: Raft for prod; Lease for small/test.</li></ul><h3 id="negative" tabindex="-1">Negative <a class="header-anchor" href="#negative" aria-label="Permalink to &quot;Negative&quot;">​</a></h3><ul><li>Design A adds Raft operational overhead (quorum management, snapshots).</li><li>Design B has a smaller blast radius but does not generalize to N replicas; stricter reliance on correct fencing.</li><li>Additional components (sidecars, proxies) increase deployment surface.</li></ul><h3 id="neutral" tabindex="-1">Neutral <a class="header-anchor" href="#neutral" aria-label="Permalink to &quot;Neutral&quot;">​</a></h3><ul><li>Small steady‑state CPU/network overhead for heartbeats/leases; negligible compared to sequencing and DA posting.</li></ul><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><p><strong>OP conductor</strong> (industry prior art; similar to Design A):</p><ul><li>Docs: <a href="https://docs.optimism.io/operators/chain-operators/tools/op-conductor" target="_blank" rel="noreferrer">https://docs.optimism.io/operators/chain-operators/tools/op-conductor</a></li><li>README: <a href="https://github.com/ethereum-optimism/optimism/blob/develop/op-conductor/README.md" target="_blank" rel="noreferrer">https://github.com/ethereum-optimism/optimism/blob/develop/op-conductor/README.md</a></li></ul></li><li><p><strong><code>ev-node</code></strong> (architecture, sequencing):</p><ul><li>Repo: <a href="https://github.com/evstack/ev-node" target="_blank" rel="noreferrer">https://github.com/evstack/ev-node</a></li><li>Quick start: <a href="https://ev.xyz/guides/quick-start" target="_blank" rel="noreferrer">https://ev.xyz/guides/quick-start</a></li><li>Discussions/issues on sequencing API &amp; multi-sequencer behavior.</li></ul></li><li><p><strong>Lease-based leader election</strong>:</p><ul><li>Kubernetes Lease API: <a href="https://kubernetes.io/docs/concepts/architecture/leases/" target="_blank" rel="noreferrer">https://kubernetes.io/docs/concepts/architecture/leases/</a></li><li>client-go leader election helpers: <a href="https://pkg.go.dev/k8s.io/client-go/tools/leaderelection" target="_blank" rel="noreferrer">https://pkg.go.dev/k8s.io/client-go/tools/leaderelection</a></li></ul></li></ul>`,57)]))}const g=a(i,[["render",o]]);export{h as __pageData,g as default};
