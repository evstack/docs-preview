import{_ as t,c as n,a3 as a,o as i}from"./chunks/framework.BFmD_fnx.js";const g=JSON.parse('{"title":"Single Sequencer","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Single Sequencer | Rollkit"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"learn/sequencing/single.md","filePath":"learn/sequencing/single.md","lastUpdated":1752169118000}'),s={name:"learn/sequencing/single.md"};function o(l,e,r,c,u,d){return i(),n("div",null,e[0]||(e[0]=[a('<h1 id="single-sequencer" tabindex="-1">Single Sequencer <a class="header-anchor" href="#single-sequencer" aria-label="Permalink to &quot;Single Sequencer&quot;">​</a></h1><p>A single sequencer is the simplest sequencing architecture for a Rollkit-based rollup. In this model, one node (the sequencer) is responsible for ordering transactions, producing blocks, and submitting data to the data availability (DA) layer.</p><h2 id="how-the-single-sequencer-model-works" tabindex="-1">How the Single Sequencer Model Works <a class="header-anchor" href="#how-the-single-sequencer-model-works" aria-label="Permalink to &quot;How the Single Sequencer Model Works&quot;">​</a></h2><ol><li><p><strong>Transaction Submission:</strong></p><ul><li>Users submit transactions directly to the sequencer node via RPC or other interfaces.</li></ul></li><li><p><strong>Transaction Ordering:</strong></p><ul><li>The sequencer collects transactions from users and orders them into blocks according to the rollup&#39;s rules.</li></ul></li><li><p><strong>Block Production:</strong></p><ul><li>The sequencer produces new blocks at regular intervals or when enough transactions are collected.</li><li>Each block contains a batch of ordered transactions and metadata.</li></ul></li><li><p><strong>Data Availability Posting:</strong></p><ul><li>The sequencer posts the block data to the configured DA layer (e.g., Celestia, Avail, etc.).</li><li>This ensures that anyone can access the data needed to reconstruct the rollup state.</li></ul></li><li><p><strong>State Update:</strong></p><ul><li>The sequencer updates the rollup state based on the new block and makes the updated state available to light clients and full nodes.</li></ul></li></ol><h2 id="advantages" tabindex="-1">Advantages <a class="header-anchor" href="#advantages" aria-label="Permalink to &quot;Advantages&quot;">​</a></h2><ul><li><strong>Simplicity:</strong> Easy to set up and operate, making it ideal for development, testing, and small-scale deployments.</li><li><strong>Low Latency:</strong> Fast block production and transaction inclusion, since there is no consensus overhead among multiple sequencers.</li></ul><h2 id="considerations" tabindex="-1">Considerations <a class="header-anchor" href="#considerations" aria-label="Permalink to &quot;Considerations&quot;">​</a></h2><ul><li><strong>Centralization:</strong> The sequencer is a single point of control. However, this is often acceptable for many applications, especially in early stages or permissioned environments.</li><li><strong>No Fault Tolerance:</strong> If the sequencer is unavailable, the rollup cannot make progress. High-availability setups and monitoring can mitigate this risk.</li></ul><h2 id="use-cases" tabindex="-1">Use Cases <a class="header-anchor" href="#use-cases" aria-label="Permalink to &quot;Use Cases&quot;">​</a></h2><ul><li>Production rollups seeking simplicity and performance</li><li>Prototyping and development</li><li>Private or permissioned rollups</li><li>Projects that value deterministic ordering and operational control</li></ul><h2 id="future-proofing" tabindex="-1">Future-Proofing <a class="header-anchor" href="#future-proofing" aria-label="Permalink to &quot;Future-Proofing&quot;">​</a></h2><p>While the single sequencer model is robust and production-ready, Rollkit is designed to support more advanced sequencing architectures in the future. Projects can seamlessly upgrade to decentralized sequencing when the technology and their needs mature.</p>',12)]))}const p=t(s,[["render",o]]);export{g as __pageData,p as default};
