import{_ as t,c as a,a3 as n,o as s}from"./chunks/framework.BFmD_fnx.js";const g=JSON.parse('{"title":"Single Sequencer","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Single Sequencer | Rollkit"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"learn/sequencing/single.md","filePath":"learn/sequencing/single.md","lastUpdated":1752484394000}'),l={name:"learn/sequencing/single.md"};function i(o,e,r,c,d,u){return s(),a("div",null,e[0]||(e[0]=[n('<h1 id="single-sequencer" tabindex="-1">Single Sequencer <a class="header-anchor" href="#single-sequencer" aria-label="Permalink to &quot;Single Sequencer&quot;">​</a></h1><p>A single sequencer is the simplest sequencing architecture for a Rollkit-based rollup. In this model, one node (the sequencer) is responsible for ordering transactions, producing blocks, and submitting data to the data availability (DA) layer.</p><h2 id="how-the-single-sequencer-model-works" tabindex="-1">How the Single Sequencer Model Works <a class="header-anchor" href="#how-the-single-sequencer-model-works" aria-label="Permalink to &quot;How the Single Sequencer Model Works&quot;">​</a></h2><ol><li><p><strong>Transaction Submission:</strong></p><ul><li>Users submit transactions directly to the sequencer node via RPC or other interfaces.</li></ul></li><li><p><strong>Transaction Ordering:</strong></p><ul><li>The sequencer collects transactions from users and orders them into blocks according to the rollup&#39;s rules.</li></ul></li><li><p><strong>Block Production:</strong></p><ul><li>The sequencer produces new blocks at regular intervals or when enough transactions are collected.</li><li>Each block contains a batch of ordered transactions and metadata.</li></ul></li><li><p><strong>Data Availability Posting:</strong></p><ul><li>The sequencer posts the block data to the configured DA layer (e.g., Celestia, Avail, etc.).</li><li>This ensures that anyone can access the data needed to reconstruct the rollup state.</li></ul></li><li><p><strong>State Update:</strong></p><ul><li>The sequencer updates the rollup state based on the new block and makes the updated state available to light clients and full nodes.</li></ul></li></ol><h2 id="advantages" tabindex="-1">Advantages <a class="header-anchor" href="#advantages" aria-label="Permalink to &quot;Advantages&quot;">​</a></h2><ul><li><strong>Simplicity:</strong> Easy to set up and operate, making it ideal for development, testing, and small-scale deployments.</li><li><strong>Low Latency:</strong> Fast block production and transaction inclusion, since there is no consensus overhead among multiple sequencers.</li></ul><h2 id="use-cases" tabindex="-1">Use Cases <a class="header-anchor" href="#use-cases" aria-label="Permalink to &quot;Use Cases&quot;">​</a></h2><ul><li>Production rollups seeking simplicity and performance</li><li>Prototyping and development</li><li>Private or permissioned rollups</li><li>Projects that value deterministic ordering and operational control</li></ul>',8)]))}const p=t(l,[["render",i]]);export{g as __pageData,p as default};
